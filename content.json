{"meta":{"title":"SCLnotes","subtitle":"","description":"主要记录一些coding过程中踩过的坑，读过的论文","author":"Larry Song","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"读论文心得","slug":"读论文心得","date":"2022-04-19T09:20:08.000Z","updated":"2022-04-19T09:29:14.787Z","comments":true,"path":"2022/04/19/读论文心得/","link":"","permalink":"http://example.com/2022/04/19/%E8%AF%BB%E8%AE%BA%E6%96%87%E5%BF%83%E5%BE%97/","excerpt":"","text":"读论文心得F2FSmovitation: SSD随机写会导致内部碎片问题，进而降低持续SSD性能（ sustained SSD performance. ） 随机写在mobile device上很多 fsync操作触发很多，主要是由于SQLite被互联网大厂使用，为了保证数据原子性等就有很多fsync 他的main-idea: 使用Log-structure的方法，将随机写转换成顺寻写，解决motivation中的问题 为什么说他是Flash friendly 他的数据Unit是FTL操作对齐的，可以减少不必要的数据拷贝 Wandering Tree问题，递归更新可能发生，这是由于闪存本身不能原地更新导致的，引入NAT解决这个问题 Multi-head logging 没懂 Adaptive logging storatge利用率较高时，logging写入数据时不做前台清理 fsync优化：最少化需要写入下去的metadata，向前恢复策略保证一致性 如何解决WanderingTree问题 ​ 将inode、direct index、indirect index 都一视同仁成node，并且为他们中间在做一次映射（NAT），NAT是扁平结构，而其他的文件系统是缩减版，没有这一层映射。 A Compressed File System Manager for Flash Memory Based Consumer Electronics Devices主要做了两点 文件系统为了减少用户读的路径上的pagefault设计了预读机制，但对于cramFS上这种压缩类型文件系统会把所有预读的页面进行解压缩，这些解压缩都不一定非常必要。解决方法：只解压当前请求读的页面，预读页面不解压缩 当内存满了的时候，会选择一些victim page驱逐到storage上，对于一个压缩文件系统和不压缩文件系统配合的存储系统，偏向于evict不压缩文件系统的page，因此压缩的page再度有解压的开销。 How to Improve the Space Utilization of Dedup-based PCM Storage Devices?主要是做PCM上的deduplication，专注于做变长块去重并存储在PCM设备上的mapping 问题： Introduction: However, storage devices are attachedto the host system through a storage-device interface, which is usu-ally of fixed management units such as an LBA. Thus, to ultimately improve the space utilization of PCM-based storage device, the technical problem falls on (1) how to mapfixed-sized LBAs to variable-sized chunks PCM设备不是字节寻址的吗，为什么要做mapping 回答：可能是因为fs是block-based，需要做block-based2variable-size的mapping. [还有漏洞，我完全可以利用字节寻址的特性重新设计fs,不需要设计成block-based] 回答了CDC后variable-size block如何与上层fix-size block-based file system 做mapping的问题 但他是基于PCM字节寻址设备设计，所以不用过多关注读放大现象 使用类似二级页表一样的结构完成LBN-&gt;PCA之间的映射 自问自答： 为什么primary table不设计成每个Logical block entry 只存一个可变长度的项，或者设计成两个变长的？ 因为Logical Block本身是定长的，不能设计长一个变长项或者两个变长项目（相当于其中一个一定为定长） 增加、删除、修改的开销都不需要遍历，开销控制还不错 使用容器处理PCM分配的碎片问题 为什么要做：PCM上存储不定长的数据段，类似于物理内存分配的分配问题，可能会出现碎片，尤其是在回收之后。 文中容器的特点： 固定大小 有容器和不定长块的元数据 顺序写数据，数据向下生长，元数据向上生长 可能会有内部碎片，通过搬移数据和合并容器来解决 当一个不定长块需要写入到PCM后，发生的空间分配流程： 首先检查当前使用的容器顺序写是否能写下 写不下根据容器是否有碎片，挂在压缩链表&#x2F;非压缩链表中 尝试从压缩&#x2F;非压缩链表中找到一个可用容器（使用worst fit方法，即永远用free space 最多的容器） 先扫描压缩表，在扫描不压缩表 如果没能找到可以存储的新容器，则触发容器合并来尝试进一步处理 容器如何合并： 设计一个buddy-system，切分的指标在于容器的size 每次从树根开始，找最大的节点来合并，只要能够满足当前请求的chunk大小后，就立刻停止合并 合并过程中会涉及数据的搬移和元数据的重写，会带来开销 EROFS定位：只读压缩文件系统，在没有修改的场景，数据解压缩的开销比较小 解决的痛点（背景）：常规的只读文件系统压缩会有读放大问题，并且解压过程中需要消耗过多的内存和CPU资源，而且这些资源可能是白白浪费到用户没有请求的数据上去了 定长输出压缩方法这里的输入指的是未被压缩的数据块，输出指的是被压缩后的数据块。 常规的只读压缩fs中一般是做固定的输入切块，通过压缩后得到不定长的输出数据块，在顺序地写到storage中。这里使用到的是通过滑动窗口，生成压缩后大小相同的数据块，而输入数据的分割是不定长度的。 当用户请求某一未压缩的数据块（block）时候，可以定位到这个uncompressed block压缩到某一具体的compressed block（或两个compressed block，由于虚拟block被从中间切开了）。相比于原来的方法，请求某一个block时候，需要解压缩他所在chunk所压缩的所有compressed block（图上是1-7） 关于NAND FLASH FTL的简单理解 from 老狼-知乎-flash专栏 &amp; &lt;A Reconfigurable FTL (Flash TranslationLayer) Architecture for NAND Flash-Based Applications&gt; &amp; OSTEP 一个闪存芯片上有多种管理单位，其中block和page是关键的单位 NAND闪存的特性是，当发生“program”操作的时候，只能把1变成0，即我们可以把11110000改成11000000，但不能改成11111111。即有点像逻辑and操作(我们可以通过NAND这个名字联想记忆一下)。那么如何把0改回1呢？这就要靠擦除操作了，但是擦除操作只能在block的上面操作。 FTL的主要作用是完成地址映射、磨损均衡、垃圾回收 地址映射的方式主要有三种：page-level block-level hybrid-level(log block mapping) NAND FLASH上有一些空闲区域（Over Provisioning），他有几种作用 坏块处理，发现坏块可以通过映射把空间区域中的好块替换掉坏块 存储L-P映射表 给GC和磨损均衡提供腾挪空间 减少写放大 最早的FTL是通过内核驱动的形式实现的，现在变成了固件（MMC） NAND flash中每个block由多个pages组成，此外每个page除了存放数据的main area以外还有一些spare area(OOB)来存放ECC、flag、坏块标记等 ​ 从FTL来看，flash可以分为元数据区域和数据区域，上述的OP应该是约等于元数据区域 hybrid-mapping-1的基本思想 J. Kim, J. M. Kim, S. H. Noh, S. L. Min, and Y. Cho. A space-efficient flash translation layer for compactflash systems. IEEE Transactions on Con-sumer Electronics, 48(2):366–375, 2002 ​ 既然block-mapping方式的overwrite带来太多的写放大，而page-mapping又占用太多的空间，那么就做一个折中。即，一小部分区域做page-mapping，其余地区做block-mapping，做page-mapping的区域被称为log blocks。当overwrite发生时，写把数据记录到log blocks中，并且维护好page映射，log被写满时候则将log中的映射与block-mapping区域中的老旧数据做合并。根据需要overwrite数据的位置和量，可以分成switch merge（恰好log中更新的数据处于原来在同一块A上，并且A上所有的数据都需要被更新）、partial merge（恰好log中更新的pages处于原来在同一块A上、但A上还有部分pages没有更新）、full merge（log中的pages处于不同的块上）。 ​ 可以分析下使用了hybrid-mapping后，他的写放大现象缓解了多少。即，在full merge情况下，并且需要更新的所有pages全都处于不同的块中，此时退化成block-mapping的写放大情况；其他情况均高于block-mapping。 log-structure方式的写配合垃圾回收 ​","categories":[],"tags":[]},{"title":"QEMU Linux 调试开发记录","slug":"QEMU Linux 调试开发记录","date":"2022-04-19T09:20:08.000Z","updated":"2022-04-19T09:27:54.995Z","comments":true,"path":"2022/04/19/QEMU Linux 调试开发记录/","link":"","permalink":"http://example.com/2022/04/19/QEMU%20Linux%20%E8%B0%83%E8%AF%95%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"QEMU Linux 调试开发记录qemu运行ubuntu123456789101112131415161718192021222324252627282930# 制作一个disk_img文件作为磁盘qemu-img create -f qcow2 &quot;$disk_img&quot; 1T# 镜像放到CRDROM中安装到磁盘（磁盘镜像img） qemu-system-x86_64 \\ -cdrom &quot;$iso&quot; \\ -drive &quot;file=$&#123;disk_img&#125;,format=qcow2&quot; \\ -enable-kvm \\ -m 2G \\ -smp 2 \\# 在打开qemu中完成系统安装 iso-&gt;img #对原有img做一个快照，保留原有img不动，每次只修改快照 qemu-img \\ create \\ -b &quot;$disk_img&quot; \\ -f qcow2 \\ &quot;$disk_img_snapshot&quot; \\# 使用快照启动 qemu-system-x86_64 \\ -drive &quot;file=$&#123;disk_img_snapshot&#125;,format=qcow2&quot; \\ -enable-kvm \\ -m 2G \\ -smp 2 \\ -soundhw hda \\ -vga virtio \\ &quot;$@&quot; \\ # 如果想要在host与guest之间共享文件 可以使用9p设备共享 -virtfs local,path=/path/to/share,mount_tag=host0,security_model=mapped,id=host0 #启动qemu时候加入该参数 #并且在guest中mount 9p设备 mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/9p QEMU启动ARM内核 只boot内核，并且将输入输出重定向到shell中 启动内核必须要有一个initrd或者指定一个启动设备并给出启动设备文件 initrd可以理解成在使用内存模拟一个disk映像 1qemu-system-arm -M vexpress-a9 -kernel zImage -m 512M -dtb vexpress-v2p-ca9.dtb -sd ./rootfs2.ext3 -append &quot;init=/linuxrc root=/dev/mmcblk0 rw rootwait earlyprintk console=ttyAMA0&quot; -nographic -fsdev local,id=kmod_dev,path=./share,security_model=none -device virtio-9p-device,fsdev=kmod_dev,mount_tag=kmod_mount QEMU启动Ubuntu镜像 重定向输入输出到命令行1234567891011121314# 需要先在guest中设置grub转发输入输出到串口systemctl set-default multi-user.target# 修改/etc/default/grubGRUB_CMDLINE_LINUX=&quot;console=tty0 console=ttyS0,115200&quot;GRUB_TERMINAL=serialGRUB_SERIAL_COMMAND=&quot;serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1&quot;# 修改完别忘了update 其中的错误会检查sudo update-grub # 修改qemu启动参数 重要的是&quot;serial mon:stdio&quot;sudo qemu-system-x86_64 -drive &quot;file=./ubuntu-test.snapshot.qcow2,format=qcow2&quot; -enable-kvm -m 2G -smp 2 -serial mon:stdio -nographic # 大致思想是 关闭图形界面 指定命令行输出到串口 串口重定向到shell程序的标准输入输出流 QEMU启动x86 kernel 使用根文件系统123456789101112sudo qemu-system-x86_64 \\ -kernel linux-v.x.y/arch/x86_64/boot/bzImage \\ -nographic \\ -drive format=raw,file=buildroot/output/images/rootfs.ext4,if=virtio \\ -append &quot;root=/dev/vda console=ttyS0 nokaslr &quot; \\ -m 4G \\ -enable-kvm \\ -cpu host \\ -smp $(nproc) \\ # -s -S # nokaslr 如果要调试请加入此配置 # 注意 如果找不到虚拟设备可能是因为内核缺少 CONFIG_VIRTIO_BLK=y CONFIG_VIRTIO_PCI=y =m不行","categories":[],"tags":[]}],"categories":[],"tags":[]}